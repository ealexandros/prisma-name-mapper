import { type DMMF, type GeneratorOptions } from "@prisma/generator-helper";
import { promises as fs } from "fs";
import path from "path";
import { styleText } from "util";
import { parseConfig } from "./utils/parse-config";

type NameMapping = Record<string, { dbName: string; fields: Record<string, string> }>;

const FILE_HEADER = `
// ðŸ”´ï¸ AUTO-GENERATED FILE â€” DO NOT EDIT! ðŸ”´
// This file was generated by the "Prisma Name Mapper Generator".
// Any manual changes will be overwritten.
`.trim();

const formatAsTypescriptConst = (object: object, constantName: string): string => {
  const jsonString = JSON.stringify(object, null, 2);
  const objectLiteralString = jsonString.replace(/"([^"]+)":/g, "$1:");

  return `${FILE_HEADER}\n\nexport const ${constantName} = ${objectLiteralString} as const;`;
};

const generateNameMapping = (models: readonly DMMF.Model[]): NameMapping => {
  const mappings: NameMapping = {};

  models.forEach(model => {
    mappings[model.name] = {
      dbName: model.dbName || model.name,
      fields: {},
    };
    model.fields.forEach(field => {
      if (field.kind === "scalar" || field.kind === "unsupported") {
        mappings[model.name].fields[field.name] = field.dbName || field.name;
      }
    });
  });

  return mappings;
};

export const onGenerate = async (options: GeneratorOptions) => {
  const config = parseConfig(options.generator.config);

  if (!config.output) {
    throw new Error(
      styleText("red", `[Prisma Name Mapper] Error: The 'output' path is required.`),
    );
  }

  const nameMap = generateNameMapping(options.dmmf.datamodel.models);
  const fileContent = formatAsTypescriptConst(nameMap, "PrismaNameMapper");

  await fs.mkdir(path.dirname(config.output), { recursive: true });
  await fs.writeFile(config.output, fileContent);
};
